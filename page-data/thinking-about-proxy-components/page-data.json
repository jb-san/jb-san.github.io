{"componentChunkName":"component---node-modules-gatsby-theme-blog-src-templates-post-js","path":"/thinking-about-proxy-components","webpackCompilationHash":"db8948e78832d650dd81","result":{"data":{"post":{"id":"49069d0b-5944-5af8-ba1e-603f2b76cd07","title":"Thinking about proxy components","date":"December 17, 2019","excerpt":"Refactorability is.. not a word, but it should be, it should be defined as To which degree or factor a piece of code or application is able…","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Thinking about proxy components\",\n  \"date\": \"2019-12-17T00:00:00.000Z\",\n  \"tags\": [\"react\", \"components\", \"pattern\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Refactorability is.. not a word, but it should be, it should be defined as\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"To which degree or factor a piece of code or application is able to be changed with minimal impact on the code/application as a whole.\")), mdx(\"p\", null, \"Refactorability and maintainability are closely related but separate concepts in my mind.\\nmaintainable code is something that can you write and make an effort to keep maintainable, and of course all of us should strive to write\\nmaintainable code, but what is refactorable code ?\"), mdx(\"p\", null, \"Well, I don\\u2019t think there is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"one\"), \" answer to this, i found myself thinking about this on a recent project i was working on.\\nIf we take the above made up definition, refactorable code should make it easy to change without having much of an impact on other code using that code,\"), mdx(\"p\", null, \"I was working on a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"legacy\"), \" application, well it was using 6 month old packages witch is legacy in the frontend world..\\nhaving old packages is not a problem in it self, but the application that was basically a large dynamic form, and it had grown so much since its first inception\\nthat we where experiencing some problems with sluggish inputs due to using the otherwise excellent \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.npmjs.com/package/formik\"\n  }), \"formik\"), \" library.\\nSo, I decided to try out the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.npmjs.com/package/react-final-form\"\n  }), \"react-final-form\"), \" library, that has more fine grained control to optimize rendering.\\nafter some initial testing, it looked promising, so when i decided to replace formik I had \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"import { Field } from 'formik'\"), \" sprinkled throughout the various components..\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"sigh\")), mdx(\"p\", null, \"but just I\\u2019ll just do a quick search & replace for\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"import { Field } from 'formik' -> import { Field } from 'react-final-form'\")), mdx(\"p\", null, \"and everything should be fine right ?\"), mdx(\"p\", null, \"well no so fast, The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Field\"), \" from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"formik\"), \" does not have exactly the same props as the one from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"react-final-form\"), \"\\nso for each place where i used \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Field\"), \" i need to change it so the props are the ones that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Field\"), \" component from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"react-final-form\"), \" expects.\"), mdx(\"p\", null, \"I decided that it would be nice to have a local \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"components/Field\"), \" component, where i transform the props into the appropriate shape for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"react-final-form\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Field\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"import { Field as FinalFormField } from \\\"react-final-form\\\"\\nexport default function Field(props) {\\n  //... tranform the props\\n  return <FinalFormField {...transformedProps} />\\n}\\n\")), mdx(\"p\", null, \"and I lived happily ever after\\u2026 almost, at the last moment we decided to update the version of our internal component library, where a breaking change to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Input\"), \" component, made it so that\\neverywhere where we had imported it like\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"import FormInput from \\\"componentlib/lib/FormInput\\\"\\n\")), mdx(\"p\", null, \"i now had to do a\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"import { FormInput } from \\\"componentlib\\\"\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"hey\"), \" this looks familiar, an \\u201Cthird party\\u201D component/library, needed to be changed, I know what to do..\"), mdx(\"p\", null, \"I create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"component/FormInput\"), \" component which I use the application, I can then transform the props if the new version of the component requires it, all in one place.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"import { FormInput as XFormInput } from \\\"componentlibX\\\"\\nexport default function FormInput(props) {\\n  //... tranform the props\\n  return <XFormInput {...transformedProps} />\\n}\\n\")), mdx(\"p\", null, \"this repeated a couple of more times and it got me thinking, could this be a good pattern ?\"), mdx(\"h2\", {\n    \"id\": \"the-pattern\"\n  }, \"The Pattern\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"For each component imported from a external library, create a local proxy component, so that if changes to the external library needs to be adapted\\nyou can do it in one place\")), mdx(\"p\", null, \"In any non trivial application you will always need to use third-party components. but when writing your actual component structure do we need to care that we are using Input from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"material-ui\"), \" or from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uilibX\"), \" ?\\nI think there is a point to always importing all components from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"components/*\"), \", so if you have an Input from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"material-ui\"), \" you should create a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Proxy component\"), \" that you then use in you app.\"), mdx(\"h3\", {\n    \"id\": \"pros\"\n  }, \"PROs\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"abstracts the third party library, so that you can make changes or update the underlying lib in one place.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"from the applications point of view you only ever import from local components, which makes it less tied to any specific library, if you want to change the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Input\"), \" component to a custom input you make the change in the local component, and not in 100 places throughout the codebase.\")), mdx(\"h3\", {\n    \"id\": \"cons\"\n  }, \"CONs\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"There is some overhead in every time you want to use a third party component, you have to create a corresponding component in your app, which can feel a bit redundant.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Hiding what library that is used is not always wanted, although once inside of the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Input\"), \" component it will be clear where it is imported from.\")), mdx(\"h2\", {\n    \"id\": \"what-makes-code-refactorable-\"\n  }, \"What makes code refactorable ?\"), mdx(\"p\", null, \"The ease to change the underlying implementation without impacting all of the components using it, or at least being able to make changes in a controlled way.\\nwith the above pattern we can update the underlying library or change it outright, and make temporary transformations to the props so that we can take our time and update the where it is used in a more controlled way.\"), mdx(\"h2\", {\n    \"id\": \"closing-thoughts\"\n  }, \"Closing thoughts\"), mdx(\"p\", null, \"This is nothing new, we are used to creating more specific components that use third-party components in our application, like we might have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Login\"), \" component that uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Auth0\"), \" and other helpers, this is just my thoughts of how I could make my applications more resilient to fundamental changes of libraries etc.\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"site":{"siteMetadata":{"title":"X3M"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"49069d0b-5944-5af8-ba1e-603f2b76cd07","excerpt":"Refactorability is.. not a word, but it should be, it should be defined as To which degree or factor a piece of code or application is able…","slug":"/thinking-about-proxy-components","title":"Thinking about proxy components","date":"December 17, 2019","siteTitle":"X3M","socialLinks":[{"name":"github","url":"https://github.com/jb-san"},{"name":"linkedin","url":"https://www.linkedin.com/in/jonathan-borg-8a520b97/"}],"previous":{"node":{"id":"aba208f0-8310-5303-a00c-b3f8a2abf4c3","excerpt":"Modals are apart of any modern website/app, hate them or love them, they do have valid use cases, even if they are often used for annoying…","slug":"/thinking-about-modals","title":"Thinking about modals","date":"December 04, 2019"}},"next":null}}}